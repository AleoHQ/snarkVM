// Copyright (C) 2019-2022 Aleo Systems Inc.
// This file is part of the snarkVM library.

// The snarkVM library is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.

// The snarkVM library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
// GNU General Public License for more details.

// You should have received a copy of the GNU General Public License
// along with the snarkVM library. If not, see <https://www.gnu.org/licenses/>.

use snarkvm_curves::AffineCurve;
use snarkvm_fields::{PrimeField, Zero};
use snarkvm_utilities::rand::UniformRand;

use rand::Rng;
use std::{
    collections::HashMap,
    ops::{Add, Mul},
};

/// The public key used to verify a threshold signature made by a group of signers.
#[derive(Clone, Debug, PartialEq, Eq)]
pub struct GroupPublicKey<G: AffineCurve>(pub G);

/// The signer's public key.
#[derive(Clone, Debug, PartialEq, Eq)]
pub struct SignerPublicKey<G: AffineCurve>(pub G);

/// The signer's secret key
#[derive(Clone, Debug, PartialEq, Eq)]
pub struct SignerSecretKey<G: AffineCurve>(pub G::ScalarField);

/// The list of signer public keys and the group public key.
#[derive(Clone, Debug, PartialEq, Eq)]
pub struct PublicKeys<G: AffineCurve> {
    /// The map of all participant public keys.
    pub public_keys: HashMap<u64, SignerPublicKey<G>>,
    /// The group public key used to verify the final threshold signature.
    pub group_public_key: GroupPublicKey<G>,
}

/// A signer's share that includes its secret key and all publicly known keys/commitments.
#[derive(Clone, Debug, PartialEq, Eq)]
pub struct SignerShare<G: AffineCurve> {
    /// The index of the participant.
    pub participant_index: u64,
    /// The participant's secret key share.
    pub secret_key: SignerSecretKey<G>,
    /// The participant's public key.
    pub public_key: SignerPublicKey<G>,
    /// The group public key used to verify the final threshold signature.
    pub group_public_key: GroupPublicKey<G>,
    /// The public commitments to the coefficients (generated by each participant).
    pub commitment: Vec<G>,
}

impl<G: AffineCurve> SignerShare<G> {
    /// Verify that the secret share was generated correctly and matches the commitment.
    pub fn is_valid(&self) -> bool {
        let expected_result = G::prime_subgroup_generator().mul(self.secret_key.0);

        let index_scalar = G::ScalarField::from_repr((self.participant_index as u64).into()).unwrap();
        let mut result = G::zero().to_projective();
        for (i, c) in self.commitment.iter().rev().enumerate() {
            result = result.add(c.to_projective());

            if i != self.commitment.len() - 1 {
                result = result.mul(index_scalar);
            }
        }

        expected_result == result.into()
    }
}

/// Generate the participant keys using a trusted authority/dealer. This process can be done with
/// DKG, but for simplicity we will use a trusted dealer model. This trusted dealer model only
/// generates a single polynomial for all participants, and then uses the indexes to determine
/// secret shares for each participant.
///
/// The `secret` attribute is randomly sampled and passed through for testing purposes.
/// g^`secret` = GroupPublicKey
pub fn trusted_keygen<R: Rng, G: AffineCurve>(
    num_participants: u8,
    threshold: u8,
    secret: &G::ScalarField,
    rng: &mut R,
) -> (Vec<SignerShare<G>>, PublicKeys<G>) {
    if num_participants < 1 {
        panic!("The number of participants must be greater than 0.");
    }

    if threshold < 1 || threshold > num_participants {
        panic!("The threshold must be between 1 and num_participants");
    }

    let mut coefficients: Vec<G::ScalarField> = Vec::with_capacity(threshold as usize);
    let mut share_commitment: Vec<G> = Vec::with_capacity(threshold as usize);

    // FROST KeyGen Round 1.1: Generate the polynomial coefficients.
    coefficients.push(*secret);
    for _ in 0..threshold - 1 {
        coefficients.push(G::ScalarField::rand(rng));
    }

    // TODO (raychu86): Generate the proof of knowledge of the very first coefficient.

    // FROST KeyGen Round 1.3: Generate the public commitments.
    for coeff in &coefficients {
        share_commitment.push(G::prime_subgroup_generator().mul(*coeff).into());
    }

    // Generate the group secret key from the provided secret.
    let group_public_key = GroupPublicKey(G::prime_subgroup_generator().mul(*secret).into());

    // FROST KeyGen Round 2: Generate the secret shares for each participant using a centralized authority.
    // As described in https://github.com/isislovecruft/frost-dalek/blob/main/src/keygen.rs
    let mut shares = Vec::with_capacity(num_participants as usize);
    let mut participant_public_keys: HashMap<u64, SignerPublicKey<G>> =
        HashMap::with_capacity(num_participants as usize);

    for index in 1..num_participants + 1 {
        // Evaluate the polynomial at point `index`.
        let index_scalar = G::ScalarField::from_repr((index as u64).into()).unwrap();
        let mut result = G::ScalarField::zero();
        for (i, coeff) in coefficients.iter().rev().enumerate() {
            result += coeff;

            if i != coefficients.len() - 1 {
                result *= index_scalar;
            }
        }

        let public_key = SignerPublicKey(G::prime_subgroup_generator().mul(result).into());

        let secret_share = SignerShare {
            participant_index: index as u64,
            secret_key: SignerSecretKey(result),
            public_key: public_key.clone(),
            group_public_key: group_public_key.clone(),
            commitment: share_commitment.clone(),
        };

        participant_public_keys.insert(index as u64, public_key);
        shares.push(secret_share);
    }

    let public_keys = PublicKeys { public_keys: participant_public_keys, group_public_key };

    (shares, public_keys)
}

#[cfg(test)]
mod test {
    use super::*;

    use crate::utils::*;

    use anyhow::Result;
    use snarkvm_curves::edwards_bls12::EdwardsAffine as EdwardsBls12Affine;
    use snarkvm_utilities::test_rng;

    /// Reconstruct the secret if there are enough participant shares (greater or equal to threshold).
    pub fn reconstruct_secret<G: AffineCurve>(participants: &[SignerShare<G>]) -> Result<SignerSecretKey<G>> {
        let indexes = participants.iter().map(|p| p.participant_index).collect::<Vec<_>>();

        let mut reconstructed_secret = G::ScalarField::zero();

        for participant in participants {
            let coeff = calculate_lagrange_coefficients::<G>(participant.participant_index, &indexes)?;

            reconstructed_secret += participant.secret_key.0.mul(coeff);
        }

        Ok(SignerSecretKey(reconstructed_secret))
    }

    #[test]
    fn test_single_participant_trusted_keygen() {
        let mut rng = test_rng();

        let threshold = 1;
        let num_participants = 1;

        // Sample the `secret`where g^`secret` = GroupPublicKey.
        let secret = <EdwardsBls12Affine as AffineCurve>::ScalarField::rand(&mut rng);

        let (shares, public_keys) =
            trusted_keygen::<_, EdwardsBls12Affine>(num_participants, threshold, &secret, &mut rng);

        assert_eq!(shares.len(), num_participants as usize);
        assert_eq!(public_keys.public_keys.len(), num_participants as usize);

        for (index, share) in shares.iter().enumerate() {
            assert_eq!(share.participant_index, index as u64 + 1);
            assert_eq!(share.group_public_key.0, public_keys.group_public_key.0);
            assert_eq!(share.commitment.len(), threshold as usize);
            assert!(share.is_valid());
        }
    }

    #[test]
    fn test_3_out_of_5_trusted_keygen() {
        let mut rng = test_rng();

        let threshold = 3;
        let num_participants = 5;

        // Sample the `secret`where g^`secret` = GroupPublicKey.
        let secret = <EdwardsBls12Affine as AffineCurve>::ScalarField::rand(&mut rng);

        let (shares, public_keys) =
            trusted_keygen::<_, EdwardsBls12Affine>(num_participants, threshold, &secret, &mut rng);

        assert_eq!(shares.len(), num_participants as usize);
        assert_eq!(public_keys.public_keys.len(), num_participants as usize);

        for (index, share) in shares.iter().enumerate() {
            assert_eq!(share.participant_index, index as u64 + 1);
            assert_eq!(share.group_public_key.0, public_keys.group_public_key.0);
            assert_eq!(share.commitment.len(), threshold as usize);
            assert!(share.is_valid());
        }
    }

    #[test]
    fn test_6_out_of_10_trusted_keygen() {
        let mut rng = test_rng();

        let threshold = 6;
        let num_participants = 10;

        // Sample the `secret`where g^`secret` = GroupPublicKey.
        let secret = <EdwardsBls12Affine as AffineCurve>::ScalarField::rand(&mut rng);

        let (shares, public_keys) =
            trusted_keygen::<_, EdwardsBls12Affine>(num_participants, threshold, &secret, &mut rng);

        assert_eq!(shares.len(), num_participants as usize);
        assert_eq!(public_keys.public_keys.len(), num_participants as usize);

        for (index, share) in shares.iter().enumerate() {
            assert_eq!(share.participant_index, index as u64 + 1);
            assert_eq!(share.group_public_key.0, public_keys.group_public_key.0);
            assert_eq!(share.commitment.len(), threshold as usize);
            assert!(share.is_valid());
        }
    }

    #[test]
    fn test_trusted_keygen_verifiable_secret_sharing() {
        let mut rng = test_rng();

        let threshold = 6;
        let num_participants = 10;

        // Sample the `secret`where g^`secret` = GroupPublicKey.
        let secret = <EdwardsBls12Affine as AffineCurve>::ScalarField::rand(&mut rng);

        let (shares, _) = trusted_keygen::<_, EdwardsBls12Affine>(num_participants, threshold, &secret, &mut rng);

        let enough_participants = shares[0..threshold as usize].to_vec();
        let reconstructed_secret = reconstruct_secret(&enough_participants).unwrap();
        assert_eq!(reconstructed_secret.0, secret);

        let not_enough_participants = shares[0..threshold as usize - 1].to_vec();
        let reconstructed_secret = reconstruct_secret(&not_enough_participants).unwrap();
        assert_ne!(reconstructed_secret.0, secret);
    }
}
